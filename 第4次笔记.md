
# 定时器
定时器的核心是一个加1计数器，每来一个脉冲，计数值自动加1。当计数值从全1（0xFFFF）再加1变成0时，会溢出并置位中断标志（TF0/TF1），同时可以触发中断  
作用：【1】用于计算时间，或使得程序每隔一段时间完成一项操作；  
【2】代替时间长的延时函数，提高GPU的运行效率和处理速度。  
## 89C52定时器资源
数量：3个（T0、T1、T2）  
T0和T1有四种工作模式(由TMOD的M0、M1位决定）：  
【0】：13位计时器；  
【1】：16位计数器（最常用），最大计数值65536；  
【2】：8位重装模式；  
【3】：两个8位计数器。  
工作模式【1】：时钟（SYSclk（系统时钟，即晶振周期），给1计数器，给2定时器） 计数（利用TH、TL计数，时钟为它提供脉冲,最大65535，溢出后申请中断） 中断  
## 定时器初值计算
定时器的计数脉冲频率 = 晶振频率 / 12（因为 51 单片机一个机器周期包含 12 个时钟周期）  
若需要定时时间为T（秒），则需要的计数次数N：N=T*晶振频率/12；  
由于定时器是加1计数，从初值X开始计数，经过N次后溢出，因此：X=65536-N。
### 当晶振频率为11.0592MHz
N取922，转化为16进制：64614=0xFC66；
## 定时器相关寄存器
寄存器（连接软硬件的媒介）：在单片机中寄存器是特殊的RAM寄存器，一方面存储和读取数据，一方面控制内部电路的连接  
### TMOD
定时器模式寄存器，高4位控制T1，低4位控制T0。我们需要设置T0的模式1，即M1=0，M0=1。  
### TH0、TL0
定时器0的初值寄存器（高8位和低8位）。我们要根据所需定时时间计算初值，写入这两个寄存器。  
### TCON
控制寄存器，其中的TR0位用于启动/停止定时器0，TF0是溢出标志（中断时会硬件清零）。
## 定时器配置
TMOD &= 0xF0;      // 清空T0的控制位（低4位清零），因为不能直接写TMOD=0x01，那样会清零高4位（影响定时器1的设置）。  
TMOD |= 0x01;      // 设置T0为模式1（M1M0=01）  
TH0 = 0xFC;        // 赋初值高8位  
TL0 = 0x66;        // 赋初值低8位  
ET0 = 1;           // 允许T0中断  
EA  = 1;           // 开总中断  
TR0 = 1;           // 启动定时器0  

## 中断系统
要求主大脑中断当前任务，处理优先级更高的紧急事件，再回到原主事件的轨迹，这种紧急事件称为中断源，主大脑优先处理紧急程度更高的事件‘  
中断嵌套：即在处理紧急事件的过程中遇到了优先级更高的事件，先中断当前紧急事件，去处理更高级事件。  
### 89C52的中断资源
中断源个数：8个（外部中断0、定时器0中断、外部中断1、定时器中断1、串口中断、外部中断2、外部中断3）  
中断优先级个数：4个  
中断号
### 中断服务函数
void Timer0_ISR() interrupt 1   // interrupt 1 是定时器0的中断号  
{
    // 重新赋初值（模式1不会自动重装，必须手动）  
    TH0 = 0xFC;
    TL0 = 0x66;  
    // 用户代码：每1ms执行的任务
}
## 数码管闪烁
用定时器可以保证精确的刷新间隔（比如每2ms切换一位），主循环只负责更新显示数字，不参与延时，从而稳定无闪烁。  
在切换位选之前，先将P0清零（消影），避免残影  
使用定时器中断相比延时函数的优势：主循环里可以不断扫描按键，LED在中断中自动翻转，互不干扰。即使用户一直按着按键，LED依然精确地每秒闪烁。